# ADR-002: Plugin Architecture para Provedores

**Status**: Aceito
**Data**: 2025-12-03
**Decisores**: Stakeholder

## Contexto

O ForgeLLMClient precisa suportar multiplos provedores LLM (OpenAI, Anthropic, futuros) com:
- Interface unificada para o usuario
- Capacidade de trocar provedor em runtime (HotSwap)
- Fallback automatico entre provedores (AutoFallback)
- Diferentes capacidades por provedor (streaming, tool calling)

## Decisao

Implementar **Plugin Architecture** usando Abstract Base Class (ABC) para definir contrato de Provider, respeitando a Orthogonal Architecture do ForgeBase.

### Interface Provider

```python
from abc import ABC, abstractmethod
from typing import AsyncIterator

class ProviderPort(ABC):
    """
    Port abstrato para provedores LLM.

    Define contrato que todos os provedores devem implementar.
    """

    @abstractmethod
    async def chat(
        self,
        messages: list[Message],
        **kwargs
    ) -> ChatResponse:
        """Enviar mensagens e receber resposta completa."""
        pass

    @abstractmethod
    async def chat_stream(
        self,
        messages: list[Message],
        **kwargs
    ) -> AsyncIterator[ChatResponseChunk]:
        """Enviar mensagens e receber resposta em streaming."""
        pass

    @property
    @abstractmethod
    def supports_streaming(self) -> bool:
        """Indica se provedor suporta streaming."""
        pass

    @property
    @abstractmethod
    def supports_tool_calling(self) -> bool:
        """Indica se provedor suporta tool calling nativo."""
        pass

    @property
    @abstractmethod
    def provider_name(self) -> str:
        """Nome identificador do provedor."""
        pass
```

### Provedores MVP

1. **OpenAIProvider** - OpenAI Responses API
2. **AnthropicProvider** - Anthropic Claude API
3. **MockProvider** - Para testes (ci_fast)

### Registry de Provedores

```python
class ProviderRegistry:
    """Registro central de provedores disponiveis."""

    def register(self, name: str, provider: ProviderPort) -> None: ...
    def get(self, name: str) -> ProviderPort: ...
    def list_available(self) -> list[str]: ...
```

## Alternativas Consideradas

### 1. Hard-coded if/else
```python
if provider == "openai":
    return OpenAIClient().chat(...)
elif provider == "anthropic":
    return AnthropicClient().chat(...)
```
- **Pros**: Simples
- **Contras**: Nao escalavel, impossivel testar isoladamente

### 2. Factory Pattern sem ABC
- **Pros**: Flexivel
- **Contras**: Sem type safety, dificil validar capacidades

### 3. Plugin Architecture com ABC (ESCOLHIDA)
- **Pros**: Type safe, extensivel, testavel, documentado
- **Contras**: Mais codigo inicial

## Consequencias

### Positivas
- Adicionar novo provedor = criar nova classe que implementa ProviderPort
- Testes isolados por provedor
- HotSwap: trocar provedor em runtime via Registry
- AutoFallback: tentar provedores em sequencia ate sucesso
- Capacidades declaradas (streaming, tool calling)

### Negativas
- Overhead de abstracacao inicial
- Todos os provedores devem implementar mesma interface

## Validacao

- [ ] OpenAIProvider implementa ProviderPort corretamente
- [ ] AnthropicProvider implementa ProviderPort corretamente
- [ ] MockProvider permite testes sem API real
- [ ] HotSwap funciona em runtime
- [ ] AutoFallback tenta proximo provedor em caso de erro

## Referencias

- `docs/guides/forgebase_guides/usuarios/extending-forgebase.md`
- ValueTrack: HotSwap, AutoFallback
